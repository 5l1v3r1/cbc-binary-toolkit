#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Binary analysis sdk for managing and submitting hashes

This is the entry point for the Binary Analysis SDK
"""

import argparse
import logging
import sys
import os

from datetime import datetime
from thespian.actors import ActorSystem, ActorExitRequest

from cbc_binary_toolkit import cli_input
from cbc_binary_toolkit import EngineResultsThread
from cbc_binary_toolkit.config import Config
from cbc_binary_toolkit.ingestion_actor import IngestionActor
from cbc_binary_toolkit.engine import LocalEngineManager
from cbc_binary_toolkit.pubsub import PubSubManager
from cbc_binary_toolkit.report_actor import ReportActor
from cbc_binary_toolkit.state import StateManager

from cbapi import CbThreatHunterAPI

LOG_LEVEL = logging.INFO
logging.basicConfig(level=LOG_LEVEL)  # Needs converted to configuration property
log = logging.getLogger(__name__)

logcfg = {
    "version": 1,
    "formatters": {
        "default": {
            "format": "%(levelname)s:%(name)s:%(message)s"
        }
    },
    "handlers": {
        "stdout": {
            "class": "logging.StreamHandler",
            "stream": sys.stdout,
            "formatter": "default"
        }
    },
    "loggers": {
        "": {
            "handlers": ["stdout"],
            "level": LOG_LEVEL
        }
    },
    'disable_existing_loggers': False,
}

if "cb-binary-analysis" in os.path.dirname(os.path.realpath(__file__)):
    default_install = os.path.join(os.path.dirname(os.path.realpath(__file__)),
                                   "../config/binary-analysis-config.yaml.example")
else:
    default_install = os.path.join(os.path.dirname(os.path.realpath(__file__)),
                                   "../carbonblackcloud/binary-sdk/binary-analysis-config.yaml.example")


def parse_args(args):
    """Create argparser"""
    parser = argparse.ArgumentParser()
    parser.add_argument("-c", "--config", type=str, default=default_install,
                        help="Location of the configuration file (default {0})".format(default_install))

    commands = parser.add_subparsers(help="Binary analysis commands", dest="command_name", required=True)

    # Analyze command parser
    analyze_command = commands.add_parser("analyze", help="Analyze a list of hashes by command line or file")
    input_type = analyze_command.add_mutually_exclusive_group(required=True)
    input_type.add_argument("-l", "--list", type=str, help="List of hashes in JSON string format")
    input_type.add_argument("-f", "--file", type=argparse.FileType('r'), help="File of hashes in json or csv format")

    # Restart command parser
    commands.add_parser("restart", help="Restart a failed job and pick up where the job crashed or exited")

    # Clear command parser
    clear_command = commands.add_parser("clear", help="Clear cache of analyzed hashes. All or by timestamp")
    clear_command.add_argument("-t", "--timestamp", type=str,
                               help="ISO 8601 date format {YYYY-MM-DD HH:MM:SS.SSS}")
    return parser.parse_args(args)


def init(actorsys, config):
    """Initialize actors"""
    state_manager = StateManager(config)

    pub_sub_manager = PubSubManager(config)
    pub_sub_manager.create_queue(config.get("engine.name"))
    pub_sub_manager.create_queue(config.get("pubsub.result_queue_name"))

    cbth = CbThreatHunterAPI(url=config.get("carbonblackcloud.url"),
                             org_key=config.get("carbonblackcloud.org_key"),
                             token=config.get("carbonblackcloud.api_token"),
                             ssl_verify=config.get("carbonblackcloud.ssl_verify"))

    injest = actorsys.createActor(IngestionActor)

    # Send requried init objects
    actorsys.ask(injest, config)
    actorsys.ask(injest, cbth)
    actorsys.ask(injest, pub_sub_manager)
    actorsys.ask(injest, state_manager)

    report = actorsys.createActor(ReportActor)

    # Send requried init objects
    ActorSystem().ask(report, cbth)
    ActorSystem().ask(report, state_manager)
    ActorSystem().ask(report, config.get("engine.name"))

    results_engine = EngineResultsThread(kwargs={'state_manager': state_manager,
                                                 'pub_sub_manager': pub_sub_manager,
                                                 'config': config,
                                                 'report_actor': report
                                                 })
    if config.get("engine.local"):
        engine_manager = LocalEngineManager(config, pub_sub_manager)

    return {
        "injest": injest,
        "engine_manager": engine_manager,
        "report": report,
        "results_engine": results_engine,
        "state_manager": state_manager
    }


def clean_up(actorsys, config, actors):
    """Clean up actors"""
    actorsys.ask(actors["injest"], ActorExitRequest())

    # Wait for results engine to finish processing results
    actors["results_engine"].join()
    if config.get("engine.local"):
        actors["engine_manager"].stop()

    actorsys.ask(actors["report"], ActorExitRequest())


def yes_or_no(question):
    """Request confirmation"""
    reply = str(input(f"{question}: (y/n)")).lower().strip()
    if reply[0] == 'y':
        return True
    if reply[0] == 'n':
        return False
    else:
        log.error("Invalid: please use y/n")
        return yes_or_no(question)


def analyze(args, actorsys, config, actors):
    """Analyze operation"""
    if args.file is not None:
        hash_group = cli_input.read_csv(args.file)
    else:
        hash_group = cli_input.read_json(args.list)

    for group in hash_group:
        actorsys.tell(actors["injest"], group)

    actors["results_engine"].start()
    actors["engine_manager"].start()

    # Wait for injestion to finish before waiting on clean_up
    for n in range(len(hash_group)):
        actorsys.listen()

    # Clean up actor
    clean_up(actorsys, config, actors)


def restart(actorsys, config, actors):
    """Restart operation"""
    actorsys.tell(actors["ingest"], ("RESTART",))

    actors["results_engine"].start()
    actors["engine_manager"].start()

    # Wait for results engine and engine_manager to finish
    clean_up(actorsys, config, actors)


def main():
    """Entry point"""
    log.info("Started: {}".format(datetime.now()))

    actorsys = ActorSystem(logDefs=logcfg)
    args = parse_args(sys.argv[1:])

    if args.config != default_install:
        config = Config.load_file(args.config)
    else:
        log.info(f"Attempting to load config from {default_install}")
        config = Config.load_file(default_install)

    if args.command_name == "analyze":
        log.info("Analyzing hashes")
        actors = init(actorsys, config)

        analyze(args, actorsys, config, actors)

    elif args.command_name == "clear":
        log.info("Clear cache")

        timestamp = args.timestamp
        if timestamp is None:
            timestamp = str(datetime.now())
        if not yes_or_no(f"Confirm you want to clear runs since {timestamp}"):
            log.info("Clear canceled")
            return

        # Clear previous states
        state_manager = StateManager(config)
        state_manager.prune(timestamp)

    elif args.command_name == "restart":
        log.info("Restart")
        actors = init(actorsys, config)

        restart(actorsys, config, actors)

    log.info("Finished: {}".format(datetime.now()))


if __name__ == '__main__':
    sys.exit(main())
